{"title":"Client Report - [Insert Project Title]","markdown":{"yaml":{"title":"Client Report - [Insert Project Title]","subtitle":"Course DS 250","author":"[Tanner Hamblin]","format":{"html":{"self-contained":true,"page-layout":"full","title-block-banner":true,"toc":true,"toc-depth":3,"toc-location":"body","number-sections":false,"html-math-method":"katex","code-fold":true,"code-summary":"Show the code","code-overflow":"wrap","code-copy":"hover","code-tools":{"source":false,"toggle":true,"caption":"See code"}}},"execute":{"warning":false}},"headingText":"Learn morea about Code Cells: https://quarto.org/docs/reference/cells/cells-jupyter.html","containsRefs":false,"markdown":"\n\n\n```{python}\nimport pandas as pd \nimport numpy as np\nimport sqlite3\nfrom lets_plot import *\n\nLetsPlot.setup_html(isolated_frame=True)\n```\n\n\n```{python}\n\n# Include and execute your code here\nsqlite_file = 'lahmansbaseballdb.sqlite'\n# this file must be in the same location as your .qmd or .py file\ncon = sqlite3.connect(sqlite_file)\n```\n\n## QUESTION|TASK 1\n\n__Write an SQL query to create a new dataframe about baseball players who attended BYU-Idaho. The new table should contain five columns: playerID, schoolID, salary, and the yearID/teamID associated with each salary. Order the table by salary (highest to lowest) and print out the table in your report.__  \n\nThe following table shows that there are 3 total baseball players records from BYUI ranging from the years 1997 to 2014. the three of them had a combined career length of 30 years and displays the salary for each year the following player played.\n\n```{python}\n# %%\nsqlite_file = 'lahmansbaseballdb.sqlite'\ncon = sqlite3.connect(sqlite_file)\n\nq = '''\n    SELECT s.salary, s.playerID, c.schoolID, s.yearID, s.teamID\n    FROM salaries s\n    LEFT JOIN collegeplaying c\n    ON s.playerID = c.playerID\n    WHERE schoolID = 'idbyuid'\n    ORDER BY salary DESC\n    \n\n    \n'''\n\n\n' '\nresults = pd.read_sql_query(q,con)\n\ndisplay(results)\n```\n\n\n## QUESTION|TASK 2\n\n__This three-part question requires you to calculate batting average (number of hits divided by the number of at-bats)__  \n    a. Write an SQL query that provides playerID, yearID, and batting average for players with at least 1 at bat that year. Sort the table from highest batting average to lowest, and then by playerid alphabetically. Show the top 5 results in your report.  \n    a. Use the same query as above, but only include players with at least 10 at bats that year. Print the top 5 results.  \n    a. Now calculate the batting average for players over their entire careers (all years combined). Only include players with at least 100 at bats, and print the top 5 results.  \n\nThe following table displays the top 5 players with the highest batting average with at least one appearance at bat. This is not a very useful table because a player that batted twice and hit both times would have a perfect AB. It is more fair to make the limit higher for AB appearances.\n\n```{python}\nq = ''' \nSelect playerID, yearID, CAST(H as Float) / CAST(AB as Float) as b\nFROM batting \nWHERE AB > 1\nORDER BY b DESC , playerID ASC \nLIMIT 5\n\n\n'''\nresults = pd.read_sql_query(q,con)\ndisplay(results) \n\n```\n\n\nThe Following Graph shows the same as the graph before but with more than 10 AB appearances. this is slightly more useful because it weeds out the people with lot AB appearances giving a more accurate representation of players that batted more than just a couple times. You notice the the batting percentage drops significantly.\n\n```{python}\nq = ''' \nSelect playerID, CAST(H as Float) / CAST(AB as Float) as b\nFROM batting \nWHERE AB > 10\nORDER BY b DESC , playerID ASC \nLIMIT 5\n\n\n'''\nresults = pd.read_sql_query(q,con)\ndisplay(results)\n\n\n```\n\nThis graph is the same as the prior with the stipulation that the player needs over 100 AB appearances. Similarly to the last one we see a relation that as we add a higher requirement of at bat appearances the bating average drops.\n```{python}\nq = ''' \nSelect playerID,AVG(CAST(H as Float) / CAST(AB as Float)) as b\nFROM batting \nWHERE AB > 100\nGROUP BY playerID\nORDER BY b DESC , playerID ASC \nLIMIT 5\n\n\n'''\nresults = pd.read_sql_query(q,con)\ndisplay(results)\n\n\n```\n\n\n## QUESTION|TASK 3\n\n__Pick any two baseball teams and compare them using a metric of your choice (average salary, home runs, number of wins, etc). Write an SQL query to get the data you need, then make a graph using Lets-Plot to visualize the comparison. What do you learn?__\n\nThe following displays a graph comparing two teams: Boston Red Stockings and Chicago White Stockings win to loss ratio in the franchises history. We can see from the graph the the Boston Red Stockings historically have been a better team if you're basing it off strictly their Win Ratio.\n\n```{python}\nq = '''\n    SELECT name, TeamID, AVG(CAST(W as float)/CAST(G as float)) as Win_Ratio\n    FROM teams\n    WHERE TeamID IN ('BS1','CH1')\n    GROUP BY name, TeamID\n    \n'''\nresults = pd.read_sql_query(q,con)\ndisplay(results)\n\n# Plot bar chart of Win_Ratio by Team\nggplot(results, aes(x='name', y='Win_Ratio')) + \\\n    geom_bar(stat = 'identity', width = .5) + \\\n    ggtitle('Historical Win Ratio Comparison') + \\\n    xlab('Team') + \\\n    ylab('Win Ratio')\n\n\n```\n\n---\n\n## STRETCH QUESTION|TASK 1\n\n__Advanced Salary Distribution by Position (with Case Statement):__  \n\n    * Write an SQL query that provides a summary table showing the average salary for each position (e.g., pitcher, catcher, outfielder). Position information can be found in the fielding table in the POS column. \n    \n        Include the following columns:\n\n        * position\n        * average_salary\n        * total_players\n        * highest_salary  \n\n    * The highest_salary column should display the highest salary ever earned by a player in that position. \n\n    * Additionally, create a new column called salary_category using a case statement:  \n\n        * If the average salary is above $3 million, categorize it as “High Salary.”\n        * If the average salary is between $2 million and $3 million, categorize it as “Medium Salary.”\n        * Otherwise, categorize it as “Low Salary.”  \n\n    * Order the table by average salary in descending order.\n\n    **Hint:** Beware, it is common for a player to play multiple positions in a single year. For this analysis, each player’s salary should only be counted toward one position in a given year: the position at which they played the most games that year. This will likely require a (sub-query)[https://docs.data.world/documentation/sql/concepts/advanced/WITH.html].\n\n\nFrom the following table we can see that in general the highest paid positions are 1st basemen making over 3 million. 2nd Basemen and Outfielders on average fall in the 2 - 3 million range. And all other positions fall in the low salary range. I thought this was interesting because everyone would assume the pitcher to be a high paying position. I think the data is skewed because if you notice the count pitcher has by far the highest. This lead me to think that there must be some low outliers dragging down average. One thing that could be done Add a having statement by position that filters out all players with lower than a certain threshold of salary.\n\n\n```{python}\nq = '''\n    SELECT  f.pos, f.G, ROUND(FORMAT(AVG(s.salary),2),2) as avg_salary, Count(*) as Count, \n    CASE \n        WHEN AVG(s.salary) > 3000000 THEN \"High Salary\"\n        WHEN AVG(s.salary) BETWEEN 2000000 AND 3000000 THEN \"Medium Salary\"\n        WHEN AVG(s.salary) < 2000000 THEN \"Low Salary\"\n        Else \"Make more Money\"\n    END as rank\n\n    From fielding f\n    JOIN(\n        SELECT yearID, playerID, MAX(G) as max_g\n        FROM fielding\n        GROUP BY yearID, playerID\n    ) mt\n    ON f.yearID = mt.yearID \n    AND f.playerID = mt.playerID \n    AND f.G = mt.max_g\n\n    JOIN salaries s\n    ON f.yearID = s.yearID\n    AND f.playerID = s.playerID\n    GROUP BY f.pos\n    \n    \n'''\nresults = pd.read_sql_query(q,con)\ndisplay(results)\n\n\n```\n\n## STRETCH QUESTION|TASK 2\n\n__Advanced Career Longevity and Performance (with Subqueries):__\n\n    * Calculate the average career length (in years) for players who have played at least **10 games**. Then, identify the top 10 players with the longest careers (based on the number of years they played). Include their: \n\n        * playerID\n        * first_name\n        * last_name\n        * career_length\n\n    * The career_length should be calculated as the difference between the maximum and minimum yearID for each player.  \n\nThe Following Graph shows the Top 10 players with the longest careers based on the debut game and their last game played this shows Nick Altrock being the player with the longest career of 35 years.\n\n```{python}\n\nq = ''' \n    SELECT p.playerID, p.nameFirst, p.nameLast, STRFTIME(\"%Y\",p.finalGame) - STRFTIME(\"%Y\", p.debut) as career_length\n    FROM people p\n    JOIN (SELECT playerID, SUM(G) as sg\n    FROM fielding\n    GROUP BY playerID \n    HAVING sg >= 10\n    ) st\n    ON p.playerID = st.playerID\n    ORDER BY career_length DESC\n    LIMIT 10\n'''\nresults = pd.read_sql_query(q,con)\ndisplay(results)\n\n\n\n```\n\nThis I found interesting because I did the same graph of the Top ten players with the longest career but this time based on their year ID. What was interesting is that between this and the last graph Nick Altrock and Arlie Latham are not on the list when compared by year ID. Why is this? My thought process is what if these two players were on the bench or still included on the roster when they were no longer playing. This is interesting to me because comparing two things that you would assume would return the same data have discrepencies.\n```{python}\n\nq = ''' \n    SELECT p.playerID, p.nameFirst, p.nameLast, may - miy as career_length\n    FROM people p\n    JOIN (SELECT playerID, SUM(G) as sg, MAX(yearID) as may, MIN(yearID) as miy\n    FROM fielding\n    GROUP BY playerID \n    HAVING sg >= 10\n    ) st\n    ON p.playerID = st.playerID\n    ORDER BY career_length DESC\n    LIMIT 10\n'''\nresults = pd.read_sql_query(q,con)\ndisplay(results)\n\n\n\n```\n---\n\n```{python}\n\nq = ''' \n    SELECT *\n    FROM batting\n    Limit 2\n    \n'''\nresults = pd.read_sql_query(q,con)\ndisplay(results)\n\n\n\n```\n---\n","srcMarkdownNoYaml":"\n\n\n```{python}\nimport pandas as pd \nimport numpy as np\nimport sqlite3\nfrom lets_plot import *\n\nLetsPlot.setup_html(isolated_frame=True)\n```\n\n\n```{python}\n# Learn morea about Code Cells: https://quarto.org/docs/reference/cells/cells-jupyter.html\n\n# Include and execute your code here\nsqlite_file = 'lahmansbaseballdb.sqlite'\n# this file must be in the same location as your .qmd or .py file\ncon = sqlite3.connect(sqlite_file)\n```\n\n## QUESTION|TASK 1\n\n__Write an SQL query to create a new dataframe about baseball players who attended BYU-Idaho. The new table should contain five columns: playerID, schoolID, salary, and the yearID/teamID associated with each salary. Order the table by salary (highest to lowest) and print out the table in your report.__  \n\nThe following table shows that there are 3 total baseball players records from BYUI ranging from the years 1997 to 2014. the three of them had a combined career length of 30 years and displays the salary for each year the following player played.\n\n```{python}\n# %%\nsqlite_file = 'lahmansbaseballdb.sqlite'\ncon = sqlite3.connect(sqlite_file)\n\nq = '''\n    SELECT s.salary, s.playerID, c.schoolID, s.yearID, s.teamID\n    FROM salaries s\n    LEFT JOIN collegeplaying c\n    ON s.playerID = c.playerID\n    WHERE schoolID = 'idbyuid'\n    ORDER BY salary DESC\n    \n\n    \n'''\n\n\n' '\nresults = pd.read_sql_query(q,con)\n\ndisplay(results)\n```\n\n\n## QUESTION|TASK 2\n\n__This three-part question requires you to calculate batting average (number of hits divided by the number of at-bats)__  \n    a. Write an SQL query that provides playerID, yearID, and batting average for players with at least 1 at bat that year. Sort the table from highest batting average to lowest, and then by playerid alphabetically. Show the top 5 results in your report.  \n    a. Use the same query as above, but only include players with at least 10 at bats that year. Print the top 5 results.  \n    a. Now calculate the batting average for players over their entire careers (all years combined). Only include players with at least 100 at bats, and print the top 5 results.  \n\nThe following table displays the top 5 players with the highest batting average with at least one appearance at bat. This is not a very useful table because a player that batted twice and hit both times would have a perfect AB. It is more fair to make the limit higher for AB appearances.\n\n```{python}\nq = ''' \nSelect playerID, yearID, CAST(H as Float) / CAST(AB as Float) as b\nFROM batting \nWHERE AB > 1\nORDER BY b DESC , playerID ASC \nLIMIT 5\n\n\n'''\nresults = pd.read_sql_query(q,con)\ndisplay(results) \n\n```\n\n\nThe Following Graph shows the same as the graph before but with more than 10 AB appearances. this is slightly more useful because it weeds out the people with lot AB appearances giving a more accurate representation of players that batted more than just a couple times. You notice the the batting percentage drops significantly.\n\n```{python}\nq = ''' \nSelect playerID, CAST(H as Float) / CAST(AB as Float) as b\nFROM batting \nWHERE AB > 10\nORDER BY b DESC , playerID ASC \nLIMIT 5\n\n\n'''\nresults = pd.read_sql_query(q,con)\ndisplay(results)\n\n\n```\n\nThis graph is the same as the prior with the stipulation that the player needs over 100 AB appearances. Similarly to the last one we see a relation that as we add a higher requirement of at bat appearances the bating average drops.\n```{python}\nq = ''' \nSelect playerID,AVG(CAST(H as Float) / CAST(AB as Float)) as b\nFROM batting \nWHERE AB > 100\nGROUP BY playerID\nORDER BY b DESC , playerID ASC \nLIMIT 5\n\n\n'''\nresults = pd.read_sql_query(q,con)\ndisplay(results)\n\n\n```\n\n\n## QUESTION|TASK 3\n\n__Pick any two baseball teams and compare them using a metric of your choice (average salary, home runs, number of wins, etc). Write an SQL query to get the data you need, then make a graph using Lets-Plot to visualize the comparison. What do you learn?__\n\nThe following displays a graph comparing two teams: Boston Red Stockings and Chicago White Stockings win to loss ratio in the franchises history. We can see from the graph the the Boston Red Stockings historically have been a better team if you're basing it off strictly their Win Ratio.\n\n```{python}\nq = '''\n    SELECT name, TeamID, AVG(CAST(W as float)/CAST(G as float)) as Win_Ratio\n    FROM teams\n    WHERE TeamID IN ('BS1','CH1')\n    GROUP BY name, TeamID\n    \n'''\nresults = pd.read_sql_query(q,con)\ndisplay(results)\n\n# Plot bar chart of Win_Ratio by Team\nggplot(results, aes(x='name', y='Win_Ratio')) + \\\n    geom_bar(stat = 'identity', width = .5) + \\\n    ggtitle('Historical Win Ratio Comparison') + \\\n    xlab('Team') + \\\n    ylab('Win Ratio')\n\n\n```\n\n---\n\n## STRETCH QUESTION|TASK 1\n\n__Advanced Salary Distribution by Position (with Case Statement):__  \n\n    * Write an SQL query that provides a summary table showing the average salary for each position (e.g., pitcher, catcher, outfielder). Position information can be found in the fielding table in the POS column. \n    \n        Include the following columns:\n\n        * position\n        * average_salary\n        * total_players\n        * highest_salary  \n\n    * The highest_salary column should display the highest salary ever earned by a player in that position. \n\n    * Additionally, create a new column called salary_category using a case statement:  \n\n        * If the average salary is above $3 million, categorize it as “High Salary.”\n        * If the average salary is between $2 million and $3 million, categorize it as “Medium Salary.”\n        * Otherwise, categorize it as “Low Salary.”  \n\n    * Order the table by average salary in descending order.\n\n    **Hint:** Beware, it is common for a player to play multiple positions in a single year. For this analysis, each player’s salary should only be counted toward one position in a given year: the position at which they played the most games that year. This will likely require a (sub-query)[https://docs.data.world/documentation/sql/concepts/advanced/WITH.html].\n\n\nFrom the following table we can see that in general the highest paid positions are 1st basemen making over 3 million. 2nd Basemen and Outfielders on average fall in the 2 - 3 million range. And all other positions fall in the low salary range. I thought this was interesting because everyone would assume the pitcher to be a high paying position. I think the data is skewed because if you notice the count pitcher has by far the highest. This lead me to think that there must be some low outliers dragging down average. One thing that could be done Add a having statement by position that filters out all players with lower than a certain threshold of salary.\n\n\n```{python}\nq = '''\n    SELECT  f.pos, f.G, ROUND(FORMAT(AVG(s.salary),2),2) as avg_salary, Count(*) as Count, \n    CASE \n        WHEN AVG(s.salary) > 3000000 THEN \"High Salary\"\n        WHEN AVG(s.salary) BETWEEN 2000000 AND 3000000 THEN \"Medium Salary\"\n        WHEN AVG(s.salary) < 2000000 THEN \"Low Salary\"\n        Else \"Make more Money\"\n    END as rank\n\n    From fielding f\n    JOIN(\n        SELECT yearID, playerID, MAX(G) as max_g\n        FROM fielding\n        GROUP BY yearID, playerID\n    ) mt\n    ON f.yearID = mt.yearID \n    AND f.playerID = mt.playerID \n    AND f.G = mt.max_g\n\n    JOIN salaries s\n    ON f.yearID = s.yearID\n    AND f.playerID = s.playerID\n    GROUP BY f.pos\n    \n    \n'''\nresults = pd.read_sql_query(q,con)\ndisplay(results)\n\n\n```\n\n## STRETCH QUESTION|TASK 2\n\n__Advanced Career Longevity and Performance (with Subqueries):__\n\n    * Calculate the average career length (in years) for players who have played at least **10 games**. Then, identify the top 10 players with the longest careers (based on the number of years they played). Include their: \n\n        * playerID\n        * first_name\n        * last_name\n        * career_length\n\n    * The career_length should be calculated as the difference between the maximum and minimum yearID for each player.  \n\nThe Following Graph shows the Top 10 players with the longest careers based on the debut game and their last game played this shows Nick Altrock being the player with the longest career of 35 years.\n\n```{python}\n\nq = ''' \n    SELECT p.playerID, p.nameFirst, p.nameLast, STRFTIME(\"%Y\",p.finalGame) - STRFTIME(\"%Y\", p.debut) as career_length\n    FROM people p\n    JOIN (SELECT playerID, SUM(G) as sg\n    FROM fielding\n    GROUP BY playerID \n    HAVING sg >= 10\n    ) st\n    ON p.playerID = st.playerID\n    ORDER BY career_length DESC\n    LIMIT 10\n'''\nresults = pd.read_sql_query(q,con)\ndisplay(results)\n\n\n\n```\n\nThis I found interesting because I did the same graph of the Top ten players with the longest career but this time based on their year ID. What was interesting is that between this and the last graph Nick Altrock and Arlie Latham are not on the list when compared by year ID. Why is this? My thought process is what if these two players were on the bench or still included on the roster when they were no longer playing. This is interesting to me because comparing two things that you would assume would return the same data have discrepencies.\n```{python}\n\nq = ''' \n    SELECT p.playerID, p.nameFirst, p.nameLast, may - miy as career_length\n    FROM people p\n    JOIN (SELECT playerID, SUM(G) as sg, MAX(yearID) as may, MIN(yearID) as miy\n    FROM fielding\n    GROUP BY playerID \n    HAVING sg >= 10\n    ) st\n    ON p.playerID = st.playerID\n    ORDER BY career_length DESC\n    LIMIT 10\n'''\nresults = pd.read_sql_query(q,con)\ndisplay(results)\n\n\n\n```\n---\n\n```{python}\n\nq = ''' \n    SELECT *\n    FROM batting\n    Limit 2\n    \n'''\nresults = pd.read_sql_query(q,con)\ndisplay(results)\n\n\n\n```\n---\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"wrap","code-link":false,"code-line-numbers":false,"code-tools":{"source":false,"toggle":true,"caption":"See code"},"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../styles.css"],"toc":true,"self-contained":true,"toc-depth":3,"number-sections":false,"html-math-method":"katex","output-file":"project2.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.27","theme":{"light":"flatly","dark":"darkly"},"title":"Client Report - [Insert Project Title]","subtitle":"Course DS 250","author":"[Tanner Hamblin]","page-layout":"full","title-block-banner":true,"toc-location":"body","code-summary":"Show the code","code-copy":"hover"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}