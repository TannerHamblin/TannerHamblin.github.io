---
title: "Client Report - [Insert Project Title]"
subtitle: "Course DS 250"
author: "[STUDENT NAME]"
format:
  html:
    self-contained: true
    page-layout: full
    title-block-banner: true
    toc: true
    toc-depth: 3
    toc-location: body
    number-sections: false
    html-math-method: katex
    code-fold: true
    code-summary: "Show the code"
    code-overflow: wrap
    code-copy: hover
    code-tools:
        source: false
        toggle: true
        caption: See code
execute: 
  warning: false
    
---


```{python}
import pandas as pd 
import numpy as np
import sqlite3
from lets_plot import *

LetsPlot.setup_html(isolated_frame=True)
```


```{python}
# Learn morea about Code Cells: https://quarto.org/docs/reference/cells/cells-jupyter.html

# Include and execute your code here
sqlite_file = 'lahmansbaseballdb.sqlite'
# this file must be in the same location as your .qmd or .py file
con = sqlite3.connect(sqlite_file)
```

## QUESTION|TASK 1

__Write an SQL query to create a new dataframe about baseball players who attended BYU-Idaho. The new table should contain five columns: playerID, schoolID, salary, and the yearID/teamID associated with each salary. Order the table by salary (highest to lowest) and print out the table in your report.__  

The following table shows that there are 3 total baseball players records from BYUI ranging from the years 1997 to 2014. the three of them had a combined career length of 30 years and displays the salary for each year the following player played.

```{python}
# %%
sqlite_file = 'lahmansbaseballdb.sqlite'
con = sqlite3.connect(sqlite_file)

q = '''
    SELECT s.salary, s.playerID, c.schoolID, s.yearID, s.teamID
    FROM salaries s
    LEFT JOIN collegeplaying c
    ON s.playerID = c.playerID
    WHERE schoolID = 'idbyuid'
    ORDER BY salary DESC
    

    
'''


' '
results = pd.read_sql_query(q,con)

display(results)
```


## QUESTION|TASK 2

__This three-part question requires you to calculate batting average (number of hits divided by the number of at-bats)__  
    a. Write an SQL query that provides playerID, yearID, and batting average for players with at least 1 at bat that year. Sort the table from highest batting average to lowest, and then by playerid alphabetically. Show the top 5 results in your report.  
    a. Use the same query as above, but only include players with at least 10 at bats that year. Print the top 5 results.  
    a. Now calculate the batting average for players over their entire careers (all years combined). Only include players with at least 100 at bats, and print the top 5 results.  

The following table displays the top 5 players with the highest batting average with at least one appearance at bat. This is not a very useful table because a player that batted twice and hit both times would have a perfect AB. It is more fair to make the limit higher for AB appearances.

```{python}
q = ''' 
Select playerID, yearID, CAST(H as Float) / CAST(AB as Float) as b
FROM batting 
WHERE AB > 1
ORDER BY b DESC , playerID ASC 
LIMIT 5


'''
results = pd.read_sql_query(q,con)
display(results) 

```


The Following Graph shows the same as the graph before but with more than 10 AB appearances. this is slightly more useful because it weeds out the people with lot AB appearances giving a more accurate representation of players that batted more than just a couple times. You notice the the batting percentage drops significantly.

```{python}
q = ''' 
Select playerID, CAST(H as Float) / CAST(AB as Float) as b
FROM batting 
WHERE AB > 10
ORDER BY b DESC , playerID ASC 
LIMIT 5


'''
results = pd.read_sql_query(q,con)
display(results)


```

This graph is the same as the prior with the stipulation that the player needs over 100 AB appearances. Similarly to the last one we see a relation that as we add a higher requirement of at bat appearances the bating average drops.
```{python}
q = ''' 
Select playerID,AVG(CAST(H as Float) / CAST(AB as Float)) as b
FROM batting 
WHERE AB > 100
GROUP BY playerID
ORDER BY b DESC , playerID ASC 
LIMIT 5


'''
results = pd.read_sql_query(q,con)
display(results)


```


## QUESTION|TASK 3

__Pick any two baseball teams and compare them using a metric of your choice (average salary, home runs, number of wins, etc). Write an SQL query to get the data you need, then make a graph using Lets-Plot to visualize the comparison. What do you learn?__

The following displays a graph comparing two teams: Boston Red Stockings and Chicago White Stockings win to loss ratio in the franchises history. We can see from the graph the the Boston Red Stockings historically have been a better team if you're basing it off strictly their Win Ratio.

```{python}
q = '''
    SELECT name, TeamID, AVG(CAST(W as float)/CAST(G as float)) as Win_Ratio
    FROM teams
    WHERE TeamID IN ('BS1','CH1')
    GROUP BY name, TeamID
    
'''
results = pd.read_sql_query(q,con)
display(results)

# Plot bar chart of Win_Ratio by Team
ggplot(results, aes(x='name', y='Win_Ratio')) + \
    geom_bar(stat = 'identity', width = .5) + \
    ggtitle('Historical Win Ratio Comparison') + \
    xlab('Team') + \
    ylab('Win Ratio')


```

---

## STRETCH QUESTION|TASK 1

__Advanced Salary Distribution by Position (with Case Statement):__  

    * Write an SQL query that provides a summary table showing the average salary for each position (e.g., pitcher, catcher, outfielder). Position information can be found in the fielding table in the POS column. 
    
        Include the following columns:

        * position
        * average_salary
        * total_players
        * highest_salary  

    * The highest_salary column should display the highest salary ever earned by a player in that position. 

    * Additionally, create a new column called salary_category using a case statement:  

        * If the average salary is above $3 million, categorize it as “High Salary.”
        * If the average salary is between $2 million and $3 million, categorize it as “Medium Salary.”
        * Otherwise, categorize it as “Low Salary.”  

    * Order the table by average salary in descending order.

    **Hint:** Beware, it is common for a player to play multiple positions in a single year. For this analysis, each player’s salary should only be counted toward one position in a given year: the position at which they played the most games that year. This will likely require a (sub-query)[https://docs.data.world/documentation/sql/concepts/advanced/WITH.html].


From the following table we can see that in general the highest paid positions are 1st basemen making over 3 million. 2nd Basemen and Outfielders on average fall in the 2 - 3 million range. And all other positions fall in the low salary range. I thought this was interesting because everyone would assume the pitcher to be a high paying position. I think the data is skewed because if you notice the count pitcher has by far the highest. This lead me to think that there must be some low outliers dragging down average. One thing that could be done Add a having statement by position that filters out all players with lower than a certain threshold of salary.


```{python}
q = '''
    SELECT  f.pos, f.G, ROUND(FORMAT(AVG(s.salary),2),2) as avg_salary, Count(*) as Count, 
    CASE 
        WHEN AVG(s.salary) > 3000000 THEN "High Salary"
        WHEN AVG(s.salary) BETWEEN 2000000 AND 3000000 THEN "Medium Salary"
        WHEN AVG(s.salary) < 2000000 THEN "Low Salary"
        Else "Make more Money"
    END as rank

    From fielding f
    JOIN(
        SELECT yearID, playerID, MAX(G) as max_g
        FROM fielding
        GROUP BY yearID, playerID
    ) mt
    ON f.yearID = mt.yearID 
    AND f.playerID = mt.playerID 
    AND f.G = mt.max_g

    JOIN salaries s
    ON f.yearID = s.yearID
    AND f.playerID = s.playerID
    GROUP BY f.pos
    
    
'''
results = pd.read_sql_query(q,con)
display(results)


```

## STRETCH QUESTION|TASK 2

__Advanced Career Longevity and Performance (with Subqueries):__

    * Calculate the average career length (in years) for players who have played at least **10 games**. Then, identify the top 10 players with the longest careers (based on the number of years they played). Include their: 

        * playerID
        * first_name
        * last_name
        * career_length

    * The career_length should be calculated as the difference between the maximum and minimum yearID for each player.  

The Following Graph shows the Top 10 players with the longest careers based on the debut game and their last game played this shows Nick Altrock being the player with the longest career of 35 years.

```{python}

q = ''' 
    SELECT p.playerID, p.nameFirst, p.nameLast, STRFTIME("%Y",p.finalGame) - STRFTIME("%Y", p.debut) as career_length
    FROM people p
    JOIN (SELECT playerID, SUM(G) as sg
    FROM fielding
    GROUP BY playerID 
    HAVING sg >= 10
    ) st
    ON p.playerID = st.playerID
    ORDER BY career_length DESC
    LIMIT 10
'''
results = pd.read_sql_query(q,con)
display(results)



```

This I found interesting because I did the same graph of the Top ten players with the longest career but this time based on their year ID. What was interesting is that between this and the last graph Nick Altrock and Arlie Latham are not on the list when compared by year ID. Why is this? My thought process is what if these two players were on the bench or still included on the roster when they were no longer playing. This is interesting to me because comparing two things that you would assume would return the same data have discrepencies.
```{python}

q = ''' 
    SELECT p.playerID, p.nameFirst, p.nameLast, may - miy as career_length
    FROM people p
    JOIN (SELECT playerID, SUM(G) as sg, MAX(yearID) as may, MIN(yearID) as miy
    FROM fielding
    GROUP BY playerID 
    HAVING sg >= 10
    ) st
    ON p.playerID = st.playerID
    ORDER BY career_length DESC
    LIMIT 10
'''
results = pd.read_sql_query(q,con)
display(results)



```
---

```{python}

q = ''' 
    SELECT *
    FROM batting
    Limit 2
    
'''
results = pd.read_sql_query(q,con)
display(results)



```
---
